### Автор: [[Роберт Мартин]]

### Главы
#### 1. Чистый код
В первой главе автор приводит аргументы почему необходимо заботится качеством кода. И что значит хороший код по мнению других людей.
Главный аргумент в необходимости качественного кода заключается в стоимости и сложности разработки. При росте объема кода вносить изменения и развивать продукт становится все сложней, и сложность растет не пропорционально объему кода. И более качественный, более читабельный и логичный код может снизить сложность рост сложности.
Некоторые мнения не от автора книги, что для них значит "чистый код":
- логика должна быть прямолинейной - что бы ошибкам было трудно спрятаться;
- производительность оптимальной - что бы не искушать оптимизировать;
- чистый код решает одну задачу;
- чистый код читается как проза;
- чистый код может читаться и усовершенствоваться другими разработчиками;
- для него написаны модульные и приемочные тесты;
- в чистом коде используются содержательные имена;
- использует минимум зависимостей;
- выглядит так, словно его автор над ним потрудился;
- в нем не будет очевидных возможностей для улучшения;
- не содержит дубликатов;
- каждая функция делает то, что от нее ожидается;

В следующих главах более детально объясняются элементы присущие "чистому коду".

#### 2. Содержательные имена
Имена переменных должны передавать намерения программиста. Они должны полно, но не избыточно описывать, что хранит переменная и зачем она была создана. Переменная должна отвечать следующим требованиям:
- переменная не должна дезинформировать
    Она должна описывать что хранит и как хранит. Стоит избегать названий вроде l и O они похожи на числа.
- имена не должны быть похожи друг на друга, они должны достаточно отличаться что бы читающий понимал в чем их различие;
- использовать удобопроизносимые имена, стараться не использовать аббревиатуры. Только если одни общеизвестны;
- имена должны быть удобно находиться;
- избегать кодирования имен, префиксов;
    Сложно поддерживать специальный "язык" для кодирования переменных
- избегать использования "I" в именах интерфейсов, лучше использовать суффикс Imp или Factory в классах реализаций и фабрик;
- не использовать однобуквенные имена переменных, за исключением коротких циклов;
- имена классов и переменных должны быть существительными. Следует избегать глаголов;
- имена методов должны быть глаголами и глагольными словосочетаниями;
- придерживаться одинаковых имен для методов с одинаковыми действиями. Например для действия получить имя может начинаться с fetch, retieve, get;
- избегать использования одинаковых глаголов для групп методов с разной функциональностью или семантикой;
- использовать общеизвестные термины из области информатики;
- добавить контекст. Поля заключенные в классе уже имеют некоторый контекст связанный с этим классом, и этим так же необходимо пользоваться;
- избегать избыточного контекста. Стараться избегать дублирования в имени класса и полях и методов этого класса.

В общем аргументы автора достаточно логичны, но как им следовать... особенно когда есть много одинаковых имен.

#### 3. Функции
Данная глава акцентирует внимание читателя на функциях, их именовании, длине и уровнях абстракции. Автор рекомендует придерживаться следующих рекомендаций:
- функции должны быть компактными, рекомендуется не более 20 строк \[1\];
- уменьшать количество строк в условиях и циклах до одной;
- уровень отступов в функции не должен быть больше одно-двух;
- функция должна выполнять только одну операцию, и делать это хорошо. Что бы это проверить можно попытаться разбить функцию на части;
- если функцию можно разбить на части (пустой строкой) значит она выполняет более одной операции и ее следует разбить;
- стремиться, что бы уровень абстракции в одной функции был на одном уровне;
- код должен читаться сверху вниз, с понижение уровня абстракций с проваливанием в функцию ниже;
- стараться избегать использования команды switch. И если она выполняет более одной операции (имеется ввиду что ее ветки используются для выбора следующей логики, а не вычисления результата) то она начинает нарушать принцип открытости/закрытости и ее код можно попытаться перенести в некоторую фабрику;
- стараться убавлять количество аргументов в функции. Как утверждает автор идеальная функция у которой нет аргументов. Автор считает, что функция с двумя аргументами это уже много, а три аргумента это уже повод серьезно задуматься. Предлагает использовать объекты в качестве аргументов \[2\]; 
- наименование функции для унарных функций удобно читается и хорошо именованным аргументом;
- функция не должна иметь побочных эффектов. Функция должна делать только то, о чем говорит ее название. Например если функция проверяет пароль, она не должна одновременно инициализировать сессию для пользователя;
- стоит избегать изменения аргументов. Разработчик не ожидает, что они будут изменяться. Если аргумент изменяется, то надо это указать в названии функции, или добавить метод в класс изменяющегося объекта;
- функция не должна одновременно что-то изменять и аргумент и возвращать какое-то значение;
- вместо возвращения ошибок, лучше кидать ошибку;
- необходимо изолировать блоки try/catch. Внутри блока должна быть только одна функция;
- так обработка ошибок это отдельная операция, то функция обрабатывающая исключение должна заниматься только этим \[3\];
- исключать дублирование. Дублирование приводит к сложно обнаруживаемым ошибкам;
- необходимо стараться, что бы функция имела одну точку входа и одну точку выхода (только один return) \[4\]. 

3.1. Не могу полностью согласится с идеей максимально убавлять длину функций. Максимально дробя их на небольшие вложенные функции. Может код написанный в одной длинной функции читается сложно, но и многоуровневые вложения функций одна в другую тоже могут порядком запутать. Пока дойдешь до последней по "уровням абстракции" функции забудешь, что делала самая первая.

3.2. Так же автор предлагает, для выполнения некоторого алгоритма, использовать не функции, а классы с вложенными в него методами выполняющими этот самый алгоритм и передавать параметры не в функцию а через конструктор класса. Не умею думать таким образом, может быть это и на самом деле удобно, но не всегда удобно использование полей класса, а не аргументов функции. И не совсем понятно как это использовать в сервиса, контроллерах и репозиториях.

3.3. Несколько странным звучит идея с блоком try/catch в отдельном методе с использованием внутри блока try/catch максимум одной функции, вплоть до оборачивания функции логирования в отдельную функцию. В итоге для одного блока try/catch необходимо три функции.

3.4. К точкам входа, думаю, что сейчас не очень актуально. А вот с точками выхода согласен, особенно если функция достаточно длинная. В короткой функции достаточно хорошо все видно. Так же считаю, что моно использовать return или бросать исключение в первой строчке, при проверке аргументов.
#### 4. Комментарии
В общем автор против комментариев, основной аргумент в том, что комментариям свойственно устаревать и зачастую их не актуализируют. Другой аргумент, в том что хорошо написанный код сам описывает, что делает. Комментарии не компенсируют плохого кода. 
Так же по комментариям можно понять, места в котором методы следует разбить на части. Если хочется вставить комментарий то может кусок кода за ним следует заменить на отдельную функцию.
Примерно так же при делении кода на части с помощью разделителей из комментариев. Это подсказка к тому, что код можно разбить на части.
В общем, с изречением, что комментарии зло не согласен. Так как этому совету уж очень просто последовать.

И хотя автор считает, что комментарии не нужны, он приводит те случаи в которых комментарии использовать уместно:
- юридические комментарии;
- комментарий к сложно читаемому коду. Например к регулярному выражению или некоторому условию, когда комментарий описывает код проще;
- когда описывает реализацию, или почему был выбран именно данный алгоритм. Акцент на каких то деталях, которые могут быть сразу не ясны;
- TODO комментарий;
- комментарии объясняющие почему сделано именно так, когда не удается объяснить это кодом;
- привлечение внимания к некоторой части кода;
- общедоступные API.

Плохие комментарии:
- непроработанные комментарии. Если необходимо оставить комментарий, то он должен быть понятен всем. То есть на комментарием так же нужно потрудиться;
- избыточные комментарии, или шум. Лишние комментарии, которые объясняют то что и так понятно, зашумляют код и делают его чтение сложней;
- недостоверные комментарии;
- позиционные комментарии, разделяющие код на логические части. Это показывает, что код можно разбить на несколько файлов;
- закомментированный код. Закомментированный код стремительно устаревает и не всегда понятно, можно ли его уже удалить.

#### Форматирование

#### Объекты и структуры данных

#### Обработка ошибок

#### Границы

#### Модульные тесты

#### Классы

#### Системы

#### Формирование архитектуры

#### Многопоточность

#### Последовательное очищение

#### Внутреннее строение JUnit

#### Переработка SerialDate

#### Запахи и эвристические правила

#### Многопоточность II